/*
    Author: Ryan Patrick
    Timestamp: Sep-29-2024
    Purpose: Implementations of routines for processing user input
 */

// Normal includes
#include "Sym_cycle_notation_parser.hpp"
#include "Sym_data_types.hpp"
#include "Sym_input_processing.hpp"

// Generated by Bison
#include "build/cycle_notation_parser.hpp"
// Generated by Flex
#include "build/cycle_notation_scanner.hpp"

// C++ Standard Library includes
#include <cassert>
#include <iostream>
#include <vector>
#include <stdexcept>

using namespace Sym;

void Sym::ProcessPermutationInput(int i, Permutation& inputBuffer, Permutation& permutation)
{
    if (inputBuffer.size() != permutation.size())
    {
        throw std::invalid_argument("Expected inputBuffer and permutation to have the same size.");
    }

    // Only allow values between 1-n inclusive
    if (inputBuffer[i] > 0 && inputBuffer[i] <= inputBuffer.size())
    {
        // A permutation is a shuffling of symbols, so repetitions can't be allowed. 
        // So, swap the existing occurrence of this symbol with this one. Example:
        /*
        **********Stage 1**********
        inputBuffer
        1 2 3 4
        1 3 2 3

        permutation
        1 2 3 4
        1 4 2 3

        **********Stage 2**********
        inputBuffer
        1 2 3 4
        1 3 2 *4*

        permutation
        1 2 3 4
        1 4 2 *4*

        **********Stage 3**********
        inputBuffer
        1 2 3 4
        1 3 2 4

        permutation
        1 2 3 4
        1 *3* 2 4

        */
        bool foundValue = false;
        for (int j = 0; j < inputBuffer.size(); j++)
        {
            if (inputBuffer[j] == inputBuffer[i] && i != j)
            {
                inputBuffer[j] = permutation[i];
                permutation[j] = permutation[i];
                foundValue = true;
                break;
            }
        }

        assert(foundValue);

        permutation[i] = inputBuffer[i];
    }
    else
    {
        inputBuffer[i] = permutation[i];
    }
}

void Sym::ShrinkPermutationByOne(Permutation& permutation)
{
    int n = static_cast<int>(permutation.size());
    for (int i = 0; i < n; i++)
    {
        if (permutation[i] == n)
        {
            permutation[i] = permutation[n - 1];
        }
    }

    permutation.resize(n - 1);
}

void Sym::CopyPermutation(Permutation& destination, Permutation& source)
{
    for (int i = 0; i < destination.size(); i++)
    {
        destination[i] = source[i];
    }
}

Permutation Sym::InitializePermutation(int size)
{
    Permutation permutation;

    for (int i = 0; i < size; i++)
    {
        permutation.push_back(i + 1);
    }

    return permutation;
}

Permutation Sym::ProcessCycleNotationInput(const char* cycleInput, const int numSymbols)
{
    Permutation result;
    
    // Communicate the number of symbols to Bison through this global variable. (Is there another way?)
    s_numSymbols = numSymbols;

    YY_BUFFER_STATE buf = yy_scan_string(cycleInput);
    yyparse(result);
    yy_delete_buffer(buf);
    
    return result;
}